---
description: frontend code convention, when start new chat use this rule for checkout project summary, 코드 제안시 해당 내용 참고  
alwaysApply: false
---

# Claude Code - 아이샵케어 프론트엔드 코드 컨벤션

## 📋 컨벤션 요약

### 🎯 핵심 원칙

1. **단일 책임 원칙**: 함수/컴포넌트는 하나의 역할만 담당
2. **지역성 원칙**: 사용하는 곳과 가까운 위치에 파일 배치
3. **응집도 최대화**: 관련된 로직과 UI를 한 곳에 모음
4. **타입 안정성**: TypeScript를 활용한 엄격한 타입 체크

---

## 🗂️ 디렉토리 구조

**한 줄 설명:** 지역성 원칙을 고려해, 실제 사용하는 곳과 가까운 위치에 파일을 둡니다.

공통 컴포넌트는 전역 디렉토리에, 도메인 컴포넌트는 도메인별 디렉토리에 위치시키고, 사용하는 곳과 가까운 위치에 파일을 둡니다.

```
/pages               # Next.js 라우트 정의
/src/pages          # 페이지별 flat 관리
  ├── components/   # 페이지별 컴포넌트
  └── hooks/        # 페이지별 훅
/src/components     # 전역 공통 컴포넌트만
/src/utils          # 도메인 독립적 유틸 함수
```

1. components만 모아두는 directory에는 반드시 애플리케이션 전역에서 공유하는 컴포넌트만 위치해야 한다. 그렇지 않은 경우는 최대한 공유하거나 사용하는 곳에서 가장 가까운 디렉토리에 위치시킨다.
2. 도메인을 알고 있는 컴포넌트는 modules 디렉토리에서 도메인 별로 관리한다.

**✅ 원칙**:

- 공통 컴포넌트 디렉토리에는 전역 공유 컴포넌트만 위치
- 도메인별 컴포넌트는 사용하는 곳과 가장 가까운 위치에 배치

---

## ⚛️ React 컴포넌트 컨벤션

### Props 처리

```tsx
// ✅ Good: 구조분해할당 사용
function Component({ title, onClick }: Props) {
  return <button onClick={onClick}>{title}</button>;
}

// ❌ Bad: props 객체 사용
function Component(props: Props) {
  const { title, onClick } = props;
  return <button onClick={props.onClick}>{props.title}</button>;
}
```

### Boolean Props

```tsx
// ✅ Good: 접두어 없이, 명시적 값 전달
<Modal open={true} clickable={false} />

// ❌ Bad: 접두어 사용, 값 생략
<Modal isOpen canClick />
```

### 이벤트 핸들러 네이밍

```tsx
// ✅ Good: handle{Target}{Event}
<Button onClick={handleButtonClick} onFocus={handleButtonFocus} />

// ❌ Bad
<Button onClick={handleClickButton} onFocus={handleFocusButton} />
```

### 조건부 렌더링

```tsx
// ✅ Good: DOM 요소 없을 때 null 반환
function EffectComponent() {
  useEffect(() => { /* side effects */ });
  return null;
}

// ✅ Good: 삼항 연산자 사용
{title != null ? <h1>{title}</h1> : null}

// ❌ Bad: 빈 Fragment, && 연산자
{title && <h1>{title}</h1>}
```

---

## 🎨 코드 스타일

### 함수 배치 순서

```tsx
// ✅ Good: 고수준 → 저수준 순서
function MainComponent() {
  return (
    <div>
      <SubComponent />
    </div>
  );
}

function SubComponent() {
  return <button>Click</button>;
}
```

### Array 메소드

```tsx
// ✅ Good: reduce with initialValue, no type assertion
arr.reduce<Item>((acc, curr) => {
  acc[[curr.id](http://curr.id)] = curr;
  return acc;
}, {});

// ✅ Good: 성능 고려 (mutate)
arr.reduce((acc, curr) => {
  acc[[curr.id](http://curr.id)] = curr;
  return acc;
}, {});

// ❌ Bad: type assertion, spread in callback
arr.reduce((acc, curr) => ({ ...acc, [[curr.id](http://curr.id)]: curr }), {} as Item);
```

### 고차함수 변수명

```tsx
// ✅ Good: 복수 → 단수 패턴
[users.map](http://users.map)(user => [user.name](http://user.name));
orders.filter(order => order.status === 'active');

// ❌ Bad: 의미없는 변수명
[list.map](http://list.map)(item => [item.name](http://item.name));
```

---

## 🔧 TypeScript 컨벤션

### Enum 대신 as const

```tsx
// ✅ Good
const Status = {
  PENDING: 'pending',
  COMPLETED: 'completed'
} as const;

// ❌ Bad
enum Status {
  PENDING = 'pending',
  COMPLETED = 'completed'
}
```

### Boolean & Null 체크

```tsx
// ✅ Good
if (value != null) { /* ... */ }

// ❌ Bad
if (!!value) { /* ... */ }
if (value === null || value === undefined) { /* ... */ }
```

### Non-null Assertion

```tsx
// ✅ Good: Suspense로 보장된 경우
function DataComponent() {
  const { data } = useDataWithSuspense();
  return <div>{data!.title}</div>;
}

// ❌ Bad: optional chaining 남용
return <div>{data?.title}</div>;
```

### 함수 타입 정의

```tsx
// ✅ Good: 함수 타입 시그니처
interface Props {
  onClick: () => void;
  onSubmit: (data: FormData) => Promise<void>;
}

// ❌ Bad: 메소드 시그니처
interface Props {
  onClick(): void;
  onSubmit(data: FormData): Promise<void>;
}
```

---

## 🌐 API & 네이밍 컨벤션

### API 함수 네이밍

```tsx
// ✅ Good: HTTP 메소드별 prefix
function fetchUserList(params: FetchUserParams) { /* GET */ }
function postUserData(params: PostUserParams) { /* POST */ }
function updateUserData(params: UpdateUserParams) { /* PUT */ }
function deleteUser(params: DeleteUserParams) { /* DELETE */ }

// ❌ Bad
function getUserList() { /* ... */ }
function createUser() { /* ... */ }
function putUser() { /* ... */ }
function removeUser() { /* ... */ }
```

### React Query 훅

```tsx
// ✅ Good: GET 요청에서 get 생략
function useUsers() {
  return useSuspenseQuery({ /* ... */ });
}

// ❌ Bad
function useGetUsers() {
  return useSuspenseQuery({ /* ... */ });
}
```

---

## 📚 외부 라이브러리

### Toss 패키지 적극 활용

```tsx
// ✅ Good: es-toolkit, react-simplikit 사용
import { sum, objectEntries } from 'es-toolkit';
import { useBooleanState } from 'react-simplikit';

const total = sum(amounts);
const entries = objectEntries(data);
const [isOpen, open, close] = useBooleanState(false);

// ❌ Bad: 네이티브 메소드 남용
const total = amounts.reduce((acc, curr) => acc + curr, 0);
const entries = Object.entries(data);
```

### 라이브러리 타입 체크

```tsx
// ✅ Good: 타입 가드 함수 사용
function isTossPaymentsError(err: unknown): err is TossPaymentsError {
  if (typeof err !== 'object' || err == null) {
    return false;
  }
  return ['message', 'success'].every(prop => prop in err);
}

if (isTossPaymentsError(error)) {
  console.log(error.message);
}

// ❌ Bad: instanceof 사용
if (error instanceof TossPaymentsError) {
  console.log(error.message);
}
```

---

## 🎯 상태 관리

### 단일 상태 기준 분기 처리

```tsx
// ✅ Good: 하나의 상태값 기준
const [contentStatus, setContentStatus] = useState(ContentStatus.기본);

const component = match(contentStatus)
  .with(ContentStatus.로딩, () => <LoadingSpinner />)
  .with(ContentStatus.에러, () => <ErrorMessage />)
  .with(ContentStatus.완료, () => <Content />)
  .exhaustive();

// ❌ Bad: 여러 상태값 조합
const [loading, setLoading] = useState(false);
const [error, setError] = useState(false);

{!loading && !error && <Content />}
{loading && <LoadingSpinner />}
{error && <ErrorMessage />}
```


